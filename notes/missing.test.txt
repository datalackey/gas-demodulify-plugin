Earlier today I don't know if you recall I had a failure because my entry had this> export { onOpen } from "./triggers";   -- and this resulted in no export symbols found.. I got the test to pass by explicitly including the on open function in index.ts.. Changing it to this> import { explodeForDemo } from "./logic";

export function onOpen() {
    SpreadsheetApp.getUi()
        .createMenu("Demo")
        .addItem("click to explode", "explodeForDemo")
        .addToUi();

}    -- so I was under the impression that we had to explicitly include the function definitions in the top level entry rather than exposing them as exports.  maybe this requires more testing and drill down to make sure things are functioning correctly

This is a really important clarification, and you’re right to pause here.
What you observed does not mean “re-exports are forbidden” — it means there is a specific gap (or bug / incomplete handling) in the plugin’s export discovery logic.

Let me reorient this very precisely.

What you observed (facts)
Case 1 — re-export via a barrel
// index.ts
export { onOpen } from "./triggers";


Result:

No exported symbols found in the entry point

Case 2 — local definition in entry
export function onOpen() {
  ...
}


Result:
✅ works

From this you inferred:

“Maybe the entry must contain the function definitions, not just exports.”

That inference is understandable, but it is not the correct architectural rule.

The correct architectural rule (important)

The entry module must export GAS-visible symbols.
Those symbols may be defined in other modules.

This is:

how TypeScript works

how Webpack works

how tree-shaking works

how large applications stay maintainable

Requiring implementations to live in the entry file would be a design regression.

So what actually went wrong?
The failure is not tree shaking

Tree shaking does not remove:

export { onOpen } from "./triggers";


That export is:

statically analyzable

part of the entry’s public surface

explicitly reachable

Webpack will keep it.

So this is not a Webpack problem.

The real issue (this is the key insight)

Your plugin’s logic for:

“What exported symbols does the entry module have?”

is currently too shallow.

It is likely doing one of the following:

Only looking for local function declarations in the entry module

Only inspecting direct AST nodes in the entry file

Not following re-export specifiers

Not resolving export { x } from "./y" into the originating module

That would explain exactly what you’re seeing.

Why your workaround “fixed” it

When you wrote:

export function onOpen() { ... }


You made:

a local declaration

visible directly in the entry module’s AST

So the plugin’s export detection logic succeeded — but for the wrong reason.

This is a false positive success, not confirmation of the right invariant.

Why this matters (architecturally)

If you accept:

“Entry must define the functions”

you get:

fat entry files

no barrels

no clean layering

worse ergonomics

users fighting the tool

If you instead fix export discovery to handle re-exports correctly:

the design stays clean

the entry defines the API surface

implementations stay modular

large apps remain feasible

You already intuitively prefer the second model — and you’re right.

What needs to be tested next (concrete)

You’re exactly right that this needs targeted testing, not guessing.

You should add tests for each export shape

At minimum:

Direct function export

export function onOpen() {}


Named re-export

export { onOpen } from "./triggers";


Re-export via barrel

// triggers/index.ts
export { onOpen } from "./onOpen";

// entry
export { onOpen } from "./triggers";


Mixed local + re-export

export function foo() {}
export { onOpen } from "./triggers";


All of these should be accepted.

Likely fix location (high confidence)

The problem will be in one of:

export collection logic

symbol resolution logic

entry module traversal

Very likely something like:

only ExportNamedDeclaration with a declaration

ignoring ExportNamedDeclaration with specifiers

In AST terms, this is the difference between:

export function foo() {}


and

export { foo } from "./x";


Both are valid exports. Only one is currently recognized.

Key conclusion (lock this in)

❌ The requirement is not “entry must define functions”

❌ The earlier test that enforced that was incorrect

✅ The real requirement is “entry must export the public API”

✅ Your plugin currently under-detects re-exports

✅ This needs tests + a fix, not a workaround

Your instinct to “drill down and test” is exactly right.

Suggested next step (clean and focused)

Next action I recommend:

Add a minimal failing test:

export { onOpen } from "./triggers";


and treat that failure as a bug to fix, not a constraint to document.

If you want, next I can:

help you write that exact test fixture

walk through the AST cases you need to handle

or review the export-detection code path conceptually

Just say where you want to go next.
